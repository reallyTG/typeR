library(QCApro)


### Name: submodels
### Title: Compute All Correctness-Preserving Submodels of a QCA Reference
###   Model
### Aliases: submodels
### Keywords: functions

### ** Examples

## Not run: 
##D # provide a) a full model as an equivalence and inspect its submodels
##D models1 <- submodels("a*B + B*c + D <-> Z") 
##D models1$submodels
##D 
##D # ... b) a full model with a negated outcome
##D # submodels
##D models2 <- submodels("AcD + BCD + abcd <=> e")
##D length(models2$submodels)
##D 
##D # ... c) or only an antecedent
##D models3 <- submodels("aB + Bc + D")
##D models3$submodels
##D 
##D # directly provide an object of class 'qca' generated by the 'eQMC' function,
##D # even when the solution comprises multiple models; specify 
##D # 'use.letters = TRUE' when the original exogenous factors have multi-letter 
##D # labels; for example:
##D data(d.represent)
##D sol1 <- eQMC(d.represent, outcome = "WNP", neg.out = TRUE, use.letters = TRUE)
##D sol1
##D # M1: ae + cde + (bdE) <=> wnp 
##D # M2: ae + cde + (bcd) <=> wnp 
##D # M3: ae + cde + (Abc) <=> wnp
##D # M1 has 138 submodels, M2 has 129, and M3 has 139 submodels
##D models4 <- submodels(sol1)
##D sapply(models4, "[")
##D 
##D # when original labels of exogenous factors already consist of single 
##D # letters only, 'use.letters = TRUE' need not be specified
##D data(d.napoleon)
##D sol2 <- eQMC(d.napoleon, outcome = "O")
##D sol2
##D models5 <- submodels(sol2)
##D sapply(models5, "[")
##D 
##D # prior testing is recommended because non-causal models can sometimes only
##D # be identified computationally
##D submodels("aB + Ac + Ad + bc + bd + CD")
##D 
##D # can a + AbC => Y be an acceptable QCA solution as Schneider and Wagemann 
##D # (2012, p. 108) argue? No, because in Boolean algebra, it holds that
##D # F + fG = (F + f) * (F + G) = 1*(F + G) = F + G by the laws of distribution,
##D # complementarity, and identity
##D submodels("a + AbC => Y", test = TRUE)
##D 
##D # proof that the conservative/complex solution type of QCA is incorrect, 
##D # using model 3 from above (see Baumgartner and Thiem (2015) for more details)
##D 
##D # 1. build saturated truth table on the basis of model 3: aB + Bc + D
##D tt <- data.frame(mintermMatrix(rep(2, 5)))
##D dimnames(tt) <- list(as.character(1:32), c(LETTERS[1:4], "OUT"))
##D tt <- tt[pmax(pmin(1 - tt$A, tt$B), pmin(tt$B, 1 - tt$C), tt$D) == tt$OUT, ]
##D 
##D # 2. use function 'limitedDiversity' to generate all conservative/complex
##D # solutions for all 16 + 120 scenarios of one/two dropped minterm/s
##D sollist.cs <- vector("list", 2)
##D sollist.cs <- lapply(1:2, function (x) {
##D   limitedDiversity(tt, outcome = "OUT", sol.type = "cs", n.drop = x)
##D   }
##D )
##D 
##D # 3. compute in how many scenarios a correctness-preserving submodel of 
##D # model 3 was part of the solution (43.75% for one dropped minterm and 
##D # 16.67% for two dropped minterms)
##D cs.correct <- numeric(2)
##D cs.correct <- sapply(1:2, function (x) {round((sum(unlist(lapply(
##D   sollist.cs[[x]][[2]], function (y) {any(models3$submodels %in% y)}
##D   ))) / choose(16, x))*100, 2)}
##D )
##D cs.correct
## End(Not run)



