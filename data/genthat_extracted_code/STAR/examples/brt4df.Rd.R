library(STAR)


### Name: brt4df
### Title: Get Backward Recurrence Times from Data Frames Generated by
###   mkGLMdf
### Aliases: brt4df
### Keywords: models

### ** Examples

## Not run: 
##D ## Let us consider neuron 1 of the CAL2S data set
##D data(CAL2S)
##D CAL2S <- lapply(CAL2S,as.spikeTrain)
##D CAL2S[["neuron 1"]]
##D renewalTestPlot(CAL2S[["neuron 1"]])
##D summary(CAL2S[["neuron 1"]])
##D ## Make a data frame with a 4 ms time resolution
##D cal2Sdf <- mkGLMdf(CAL2S,0.004,0,60)
##D ## keep the part relative to neuron 1
##D n1.cal2sDF <- cal2Sdf[cal2Sdf$neuron=="1",]
##D ## remove unnecessary data
##D rm(cal2Sdf)
##D ## Extract the elapsed time since the second to last and
##D ## third to last for neuron 1. Normalise the result. 
##D n1.cal2sDF[c("rlN.1","rsN.1","rtN.1")] <- brt4df(n1.cal2sDF,"lN.1",2,c("rlN.1","rsN.1","rtN.1"))
##D ## load mgcv library
##D library(mgcv)
##D ## fit a model with a tensorial product involving the last
##D ## three spikes and using a cubic spline basis for the last two
##D n1S.fitA <- gam(event ~ te(rlN.1,rsN.1,bs="cr") + rtN.1,data=n1.cal2sDF,family=binomial(link="logit"))
##D summary(n1S.fitA)
##D ## plot the result in 2 different ways
##D plot(n1S.fitA)
##D vis.gam(n1S.fitA,phi=20,theta=45)
##D 
## End(Not run)



