library(crs)


### Name: crs
### Title: Categorical Regression Splines
### Aliases: crs crs.default crs.formula
### Keywords: nonparametric

### ** Examples

set.seed(42)
## Example - simulated data
n <- 1000
num.eval <- 50
x1 <- runif(n)
x2 <- runif(n)
z <- rbinom(n,1,.5)
dgp <- cos(2*pi*x1)+sin(2*pi*x2)+z
z <- factor(z)
y <- dgp + rnorm(n,sd=.5)

## Estimate a model with specified degree, segments, and bandwidth
model <- crs(y~x1+x2+z,degree=c(5,5),
                       segments=c(1,1),
                       lambda=0.1,
                       cv="none",
                       kernel=TRUE)
summary(model)

## Perspective plot
x1.seq <- seq(min(x1),max(x1),length=num.eval)
x2.seq <- seq(min(x2),max(x2),length=num.eval)
x.grid <- expand.grid(x1.seq,x2.seq)
newdata <- data.frame(x1=x.grid[,1],x2=x.grid[,2],
                      z=factor(rep(0,num.eval**2),levels=c(0,1)))
z0 <- matrix(predict(model,newdata=newdata),num.eval,num.eval)
newdata <- data.frame(x1=x.grid[,1],x2=x.grid[,2],
                      z=factor(rep(1,num.eval),levels=c(0,1)))
z1 <- matrix(predict(model,newdata=newdata),num.eval,num.eval)
zlim=c(min(z0,z1),max(z0,z1))
persp(x=x1.seq,y=x2.seq,z=z0,
      xlab="x1",ylab="x2",zlab="y",zlim=zlim,
      ticktype="detailed",      
      border="red",
      theta=45,phi=45)
par(new=TRUE)
persp(x=x1.seq,y=x2.seq,z=z1,
      xlab="x1",ylab="x2",zlab="y",zlim=zlim,
      theta=45,phi=45,
      ticktype="detailed",
      border="blue")

## Partial regression surface plot
plot(model,mean=TRUE,ci=TRUE)
## Not run: 
##D ## A plot example where we extract the partial surfaces, confidence
##D ## intervals etc. automatically generated by plot(mean=TRUE,...) but do
##D ## not plot, rather save for separate use.
##D pdat <- plot(model,mean=TRUE,ci=TRUE,plot.behavior="data")
##D 
##D ## Column 1 is the (evaluation) predictor ([,1]), 2-4 ([,-1]) the mean,
##D ## lwr, and upr (note the returned value is a `list' hence pdat[[1]] is
##D ## data for the first predictor, pdat[[2]] the second etc). Note that
##D ## matplot() can plot this nicely.
##D matplot(pdat[[1]][,1],pdat[[1]][,-1],
##D         xlab=names(pdat[[1]][1]),ylab=names(pdat[[1]][2]),
##D         lty=c(1,2,2),col=c(1,2,2),type="l")
## End(Not run)



