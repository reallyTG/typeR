---
title: "Corpus"
output: html_document
editor_options: 
  chunk_output_type: console
params:
  which_dependencies:
    - Depends
    - Imports
---

```{r setup, include=FALSE}
library(cranlogs)
library(DT)
library(fs)
library(lubridate)
library(purrr)
library(tidyverse)
library(tools)
library(withr)

knitr::opts_chunk$set(echo = TRUE)

source("inc/paths.R")
source("inc/setup.R")
source("inc/latextags.R")

options(repos=CRAN_LOCAL_MIRROR)
```

Tis Rmd file builds the project corpus.

## Loading data

### CRAN

We start with all CRAN packages that we have mirrored locally using rsync.

```{r cran packages}
pkgs_cran_raw <- available.packages(contriburl = str_c("file://", path(CRAN_MIRROR_DIR, "src", "contrib")))
pkgs_cran <- tibble(package=pkgs_cran_raw[,1])
```

### Installed packages

We tried to instal all of the `r fmt(nrow(pkgs_cran))` these packages.
Some packages failed to install, in most cases this is because of missing native dependencies.

```{r find install packages}
pkgs_installed_raw <- installed.packages(LIB_DIR)
pkgs_installed <- tibble(package=pkgs_installed_raw[,1])
```

### Loadable packages

We managed to install `r fmt(nrow(pkgs_installed))` packages.
Next is to chech how many of the installed packages can actually be loaded.
We do that by running the `package-load.R` task:

```
./rapr/inst/on-each-package.sh ./rapr/inst/tasks/package-load.R 
env-rscript ./rapr/inst/process-csv-result.R run/package-load
```

This changes wether a package can be loaded using `library(package)` call.

```{r loadable packages}
pkgs_loadable <- 
  read_parallel_run_csv(PACKAGE_LOAD_RUN) %>%
  filter(exitval==0) %>%
  rename(package=job)
```

### Package metadata

Next we pull in some package metadata.

```{r load package sloc}
pkgs_sloc_raw <- 
  read_csv(
    PACKAGE_SLOC,
    col_types=cols(
      package = col_character(),
      path = col_character(),
      files = col_double(),
      language = col_character(),
      blank = col_double(),
      comment = col_double(),
      code = col_double()
    )
  )

pkgs_sloc <- 
  pkgs_sloc_raw %>%
  filter(endsWith(path, "/R") | endsWith(path, "/src")) %>%
  select(-blank, -comment, -files, -path) %>%
  mutate(language=case_when(
    language == "R" ~ "package_r_code",
    language == "C" ~ "package_native_code",
    language == "C/C++ Header" ~ "package_native_code",
    language == "C++" ~ "package_native_code",
    startsWith(language, "Fortran") ~ "package_native_code",
    TRUE ~ as.character(NA)
  )) %>%
  filter(!is.na(language)) %>%
  group_by(package, language) %>%
  summarise(code=sum(code)) %>%
  spread(key=language, value=code, fill=0) %>%
  mutate(package_code=package_native_code + package_r_code)
```

### Package runnable code

Next to the code itself, R packages have examples, tests and vignettes.
These can include snippets of R code which calls the package functions.
We extract this code and run it to narrow down the list of packages that can be considered into the final corpus.

```{r runnable code metadata}
pkgs_runnable_code_raw <- 
  read_csv(
    PACKAGE_RUNNABLE_CODE_METADATA,
    col_types=cols(
      package = col_character(),
      path = col_character(),
      files = col_double(),
      language = col_character(),
      blank = col_double(),
      comment = col_double(),
      code = col_double()
    )
  )

pkgs_runnable_code <- 
  pkgs_runnable_code_raw %>%
  filter(language=="R") %>%
  select(package, path, code, files) %>%
  pivot_wider(
    names_from=path, 
    values_from=c(code, files), 
    values_fill=list(code=0, files=0)
  ) %>%
  # we have old version of tidyr, names_glue is missing, so have to rename manually
  rename(
    runnable_code_examples=code_examples,
    runnable_code_tests=code_tests,
    runnable_code_vignettes=code_vignettes,
    runnable_files_examples=files_examples,
    runnable_files_tests=files_tests,
    runnable_files_vignettes=files_vignettes,
  ) %>%
  mutate(
    runnable_code=runnable_code_examples+runnable_code_tests+runnable_code_vignettes,
    runnable_files=runnable_files_examples+runnable_files_tests+runnable_files_vignettes
  ) %>%
  select(
    package,
    runnable_code,
    runnable_files,
    everything()
  )
```

### Package coverage

```{r load coverage data}
pkgs_coverage <- 
  read_csv(
    PACKAGE_COVERAGE,
    col_types=cols(
      package = col_character(),
      type = col_character(),
      coverage_expression = col_double(),
      coverage_line = col_double(),
      error = col_logical()
    )
  ) %>%
  filter(type=="all", is.na(error), !is.na(coverage_expression)) %>% 
  select(-type, -error, coverage_expr=coverage_expression) %>%
  mutate(coverage_expr=coverage_expr/100, coverage_line=coverage_line/100)
```

### Package runs

```{r package runs}
pkgs_runs_raw <-
  read_csv(
    PACKAGE_RUN,
    col_types=cols(
      package = col_character(),
      file = col_character(),
      type = col_character(),
      time = col_double(),
      error = col_character(),
      output = col_character()
    )
  )
pkgs_runs <-
  pkgs_runs_raw %>%
  group_by(package) %>%
  summarise(runnable_success=sum(is.na(error)), runnable_error=sum(!is.na(error)), runnable_time=sum(time, na.rm=TRUE)) %>%
  mutate(runnable_rate=runnable_success/(runnable_success+runnable_error))
```

### Package functions

```{r load functions}
pkgs_functions <- 
  read_csv(
    PACKAGE_FUNCTIONS,
    col_types=cols(
      package = col_character(),
      fun = col_character(),
      num_params = col_double(),
      has_elipsis = col_logical(),
      exported = col_logical()
    )
  ) %>%
  count(package, exported) %>%
  mutate(type=ifelse(exported, "funs_public", "funs_private")) %>%
  select(-exported) %>%
  spread(key=type, value=n, fill=0) %>%
  mutate(funs=funs_public+funs_private)
```

### Package reverse dependencies

There are two functions `package_dependencies` and `dependsOnPkgs`.
Not sure what is the difference, but the `dependsOnPkgs` is very slow.

```{r compute reverse dependencies}
pkgs_revdeps_raw <- withr::with_libpaths(LIB_DIR, {
  package_dependencies(
    pkgs_installed$package,
    db=pkgs_installed_raw,
    which=params$which_dependencies,
    reverse=TRUE,
    recursive=FALSE
  )
}) %>% imap_dfr(~tibble(package=.y, revdep=.x))

pkgs_revdeps <- count(pkgs_revdeps_raw, package) %>% rename(revdeps=n)
```

### Package asserts

```{r runtime checks}
pkgs_asserts <- 
  read_csv(
    PACKAGE_ASSERTS,
    col_types=cols(
      package = col_character(),
      fun_name = col_character(),
      file = col_character(),
      line1 = col_double(),
      col1 = col_double(),
      line2 = col_double(),
      col2 = col_double(),
      assert = col_character(),
      args = col_character()
    )
  ) %>%
  count(package, fun_name) %>%
  group_by(package) %>%
  summarise(funs_with_assert=length(unique(fun_name)), asserts=sum(n))
```

### Package roxygen

```{r}
pkgs_roxygen <-
  read_csv(
    PACKAGE_USES_ROXYGEN,
    col_types=cols(
      package = col_character(),
      uses_roxygen = col_logical()
    )
  )
```


### Join

```{r joining data}
pkgs <-
  pkgs_cran %>%
  left_join(mutate(pkgs_installed, installed=TRUE), by="package") %>% mutate(installed=replace_na(installed, FALSE)) %>%
  left_join(transmute(pkgs_loadable, package, loadable=TRUE), by="package") %>% mutate(loadable=replace_na(loadable, FALSE)) %>%
  left_join(pkgs_sloc, by="package") %>%
  left_join(pkgs_runnable_code, by="package") %>%
  left_join(pkgs_coverage, by="package") %>%
  left_join(pkgs_runs, by="package") %>%
  left_join(pkgs_functions, by="package") %>%
  left_join(pkgs_revdeps, by="package") %>%
  left_join(pkgs_asserts, by="package") %>%
  left_join(pkgs_roxygen, by="package")
```

### Output

```{r}
write_csv(pkgs, ALL_PACKAGES_DETAILS)
write_lines(pkgs$package, ALL_PACKAGES_FILE)
```

```{r}
corpus_revdeps <- pkgs_revdeps_raw %>% semi_join(corpus, by="package")
write_csv(corpus_revdeps, CORPUS_REVDEPS)
write_lines(unique(corpus_revdeps$revdep), CORPUS_REVDEPS_UNIQUE)
```

### Sanity checks

#### Packages that are loaded, but not installed?

```{r}
filter(pkgs, !installed && loadable) %>%
  select(package, installed, loadable)
```

#### Packages that do not have any extracted runnable code, yet they have some runs or coverage?

This can actually be still OK, perhaps the package has some code in its `.onLoad` or `.onAttach` hooks.

```{r}
filter(pkgs, runnable_code==0, coverage_expr > 0) %>%
  select(package, package_code, runnable_code, runnable_files, starts_with("coverage"))
```

### Curiosity

* Packages with no R code (this is perfectly fine):

```{r}
filter(pkgs, package_r_code==0)
```

* Packages with no code at all (also fine - just data packages):

```{r}
filter(pkgs, package_code==0)
```